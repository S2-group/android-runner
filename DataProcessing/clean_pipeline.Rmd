---
title: "App vs Web App"
author: "Lucien Martijn, Stijn Meijerink, DaniÃ«l Hana, Terry Bommels, Dion David Haneveld"
date: "23 October 2020"
output: pdf_document
highlight: tango
---

```{r echo = T, results = 'hide', message=FALSE, warning=FALSE, error=FALSE}
# Include libraries used in lectures
library(tidyverse)
library(car)
library(bestNormalize)
library(ggplot2)
library(effsize)
```

First we read recursively all data collected to construct one big dataframe.
```{r echo = T, results = 'hide', message=FALSE, warning=FALSE, error=FALSE}
# Get all joule_results.*.csv
csv_paths <- list.files(path = "./Data/", 
                        recursive = TRUE, 
                        pattern = "^Joule.*\\.csv", 
                        full.names = TRUE)
# read all csv
app_data <- csv_paths %>%
  lapply(read_csv) %>%
  bind_rows

# Add paths to data frame for reading out the correct names later
app_data['path'] = csv_paths

# Based on the paths get the device tier and add it to the dataframe
app_data['device'] <- csv_paths %>%
  strsplit('-', fixed = TRUE) %>%
  rapply(nth, n=1) %>%
  strsplit('/', fixed = TRUE) %>%
  rapply(nth, n=6) %>%
  factor

extract_app_type <- function(splitString){
  temp <- strsplit(x = splitString, split = '-', fixed = TRUE)
  result <- unlist(temp)[3]
  if(str_detect(result, 'www')){
    result <- "web"
  }
  if(str_detect(result, 'runner')){
    result <- "native"
  }
  return(result)
}
# Extract app type based on path
app_type <- app_data$path %>%
  lapply(extract_app_type)
app_data['app_type']<- unlist(app_type)

extract_app_name <- function(path)  {
  temp <- strsplit(x = path, split = '/', fixed = TRUE)
  result <- unlist(temp)[7]
  if(str_detect(result, '(.*https-www.*)')){
    result <- unlist(strsplit(x = result, split = '-'))[3]
  }
  if(str_detect(result, '(.*android-runner-experiments.*)')){
    result <- unlist(strsplit(x = result, split = '-'))[6]
  }
  return(result)
}

# Extract app names based on path
app_names <- app_data$path %>%
  lapply(extract_app_name)
app_data['app'] <- unlist(app_names)

updateMisalignedAppNames <- function(app){
  if(app == 'alibaba'){
    app = 'aliexpress'
  } else if(app == 'inditex'){
    app = 'zara'
  } else if(app == 'ninegag'){
    app = '9gag'
  } else if(app == 'google'){
    app = 'youtube'
  }else {
    app = app
  }
}

# The native app name for aliexpress is Alibaba so we update it to aliexpress
updatedAppNames <- app_data$app %>%
  lapply(updateMisalignedAppNames)

# Add the updated names to the dataframe again
app_data['app'] <- unlist(updatedAppNames)

app_data$app_type <- as.factor(app_data$app_type)
app_data$app <- as.factor(app_data$app)
```
```{r}
# Show a part of the data frame
tail(app_data)
```

Let us also see if all treatments are present.
```{r}
table(app_data$device, app_data$app_type)
```

And write the full results to a file, to distribute for the replication package.
```{r}
write_csv(path = './full_results.csv', x = app_data)
```


# 1. Discriptive statistics

```{r}
# Define a summarize data function
summarize_data <- function(data){
  data %>%
  group_by(app) %>%
  summarize(n = n(), 
            mean = mean(Joule_calculated),
            median = median(Joule_calculated),
            sd = sd(Joule_calculated),
            IQR = IQR(Joule_calculated),
            min = min(Joule_calculated),
            max = max(Joule_calculated))
}

summarize_data(app_data)
```
The full data frame is summarised. We see quite some big standard deviations. If we now group by device we see a clear pattern arrise.

```{r}
app_data %>%
  group_by(app_type, device) %>%
  summarise(mean = mean(Joule_calculated),
            sd = sd(Joule_calculated))
```
This shows us that the mean of high-end data is lower. Furthermore we observe that the standard deviation is much less at the high-end deivce tier. The last observation we can make is that in general app_type web consumes more energy.

Visualizing the full data frame with a boxplot results in the following plot.
```{r}
boxplot(app_data$Joule_calculated, main = "Joules Distribution by Group",  ylab = "Joules", col = "steelblue", border = "black")
```
We see a positively skewed dataset with quite some outliers. 

Let us split this up on device type and we see two more normal distributed boxplots. However for a low-end device the distribution still has a heavy right tail.
```{r}
boxplot(Joule_calculated ~ device,
  data = app_data,
  main = "Joules Distribution by Group",
  xlab = "Group",
  ylab = "Joules",
  col = "steelblue",
  border = "black", 
  las = 2 #make x-axis labels perpendicular
)
```
<!-- IVANO's paper -->
<!-- As shown in the boxplot in Figure 2, the dataset appears quite positively skewed, with the mean higher than the median. Indeed, the data scores negatively for normality (W = 0.95141, p-value = 0.02459). This is due to the high difference in the energy consumption values between the two mobile devices, as can be also observed in the boxplot in Figure x. For this reason, for the rest of our analysis we will use the type of mobile device as a blocking factor. -->

This lets us conclude that we should take the device tier as blocking factor. For the rest of the analysis we therefore will use this as blocking factor. Therefore a two way ANOVA is not possible anymore, because we are missing the interaction factor in the model.

```{r}
# To account for both treatments on one subject (in this case app) we aggregate the data as follows:
mean_device_app_type <- app_data %>%
  group_by(app_type, device, app) %>%
  summarise(mean(Joule_calculated)) %>%
  arrange(app)

names(mean_device_app_type)[names(mean_device_app_type)=="mean(Joule_calculated)"] <- "Joule"

# This leaves us with 32 rows = 2 (app_type) * 2 (device tiers) * 8 (apps)
```


# 2. Hypothesis Testing
The back-up statisical test that we get to know is the one way ANOVA, because we are left with one response variable and one explainatiry factor (fixed on two levels). However this is equivalent to a paired t-test. Therefore we will conduct a paired t test with a split on device tier, to account for the blocking factor.

### Assumption 1
The participants should be selected randomly from the population. This has been accounted for in the experiment setup.

### Assumption 2
The differences between the pairs should be approximately normally distributed

```{r}
check_normality <- function(data){
  plot(density(data))
  car::qqPlot(data)
  shapiro.test(data)
}
```


This is aggregated over 15 datapoints per subject. Here for both low-end and high-end devices differences  are taken. This is not good, as device type is blocking factor.
```{r}
differences <- with(mean_device_app_type, Joule[app_type == "web"] - Joule[app_type == "native"])
```

```{r}
check_normality(differences)
```

Split dataset in high-tier & low-tier due to blocking factor device type (each group of 210 points)
```{r}
mean_device_app_type_high <- app_data %>%
  filter(device == 'high') %>%
  arrange(app_type, app)

mean_device_app_type_low <- app_data %>%
  filter(device == 'low') %>%
  arrange(app_type, app)
```

Check normality of differences for high end device tier:
```{r}
check_normality(with(mean_device_app_type_high, Joule_calculated[app_type == "web"] - Joule_calculated[app_type == "native"]))
# Likely to stem from normal distribution
```

Check normality of differences for low end device tier:
```{r}
check_normality(with(mean_device_app_type_low, Joule_calculated[app_type == "web"] - Joule_calculated[app_type == "native"]))
# Very likely to stem from normal distribution
```
### Assumption 3
There should be no extreme outliers in the differences

```{r}
par(mfrow=c(1,2))
boxplot(Joule_calculated~app_type, data= mean_device_app_type_high, main = "Distribution for a high end device with both app types")
boxplot(Joule_calculated~app_type, data= mean_device_app_type_low, main = "Distribution for a low end device with both app types")
```


# RQ1
RQ1 will be answered with the paired t test.

```{r}
# Perform paired t test
highRes <- t.test(Joule_calculated ~ app_type, data = mean_device_app_type_high, paired = T)
lowRes <- t.test(Joule_calculated ~ app_type, data = mean_device_app_type_low, paired = T)
highRes$p.value
lowRes$p.value
```
The obtained p-values for high-end device and low-end device are `r highRes$p.value ` and `r lowRes$p.value ` respectively. However because we perform a t test multiple times we have to adjust the p values.

```{r}
# adjust p values
adjustedPVals <- p.adjust(c(highRes$p.value, lowRes$p.value), method = 'BH')
# adjustedPVals
```
The adjusted p-values for high and low end device are `r adjustedPVals[1] ` and `r adjustedPVals[2] ` respectively.

This leads us to reject the null-hypothesis of equal means for the high-end device. For the low end device the statistical signifiance is not high enough to reject the null-hypothesis.
This leads us to the following conclusion for RQ1: for high end devices it can be said that there is a significant difference in energy consumption, whereas for a low-end device this cannot be proven (?).

# 3. Effect size
```{r}
# Effect size
cohenResHigh <- cohen.d(Joule_calculated ~ app_type, data = mean_device_app_type_high, paired = T, pooled = FALSE)
cohenResLow <- cohen.d(Joule_calculated ~ app_type, data = mean_device_app_type_low, paired = T, pooled = FALSE)

cohenResHigh$estimate #Effect size is large for high
cohenResLow$estimate #Effect size is large for low
```
Effect size for both device tiers is large.

# Extra visualizations

```{r}
font_size <- 12

visualize_both <- function(data, title){
  result <- ggplot(data, aes(x = app, y = Joule_calculated)) +
  theme_classic() +
  xlab("App") + ylab("Joules") +
  ylim(c(0, max(data$Joule) + 50)) +
  geom_boxplot(mapping = aes(label = app_type, fill = app_type), width = 1, color = 'black', outlier.size = .5, alpha = .7) +
  geom_violin(mapping = aes(label = app_type, color = app_type), trim = TRUE, alpha = .8, width = 1) +
  # stat_summary(mapping = aes(color = app_type), fun = mean, geom = 'point', shape = 5, size = 2, show.legend = T) +
  theme(
    strip.text.x = element_text(size = font_size),
    strip.text.y = element_text(size = font_size),
    axis.text.x = element_text(size = font_size),
    axis.text.y = element_text(size = font_size)
    )  +
    labs(title = title,subtitle = NULL,caption = NULL)
  
  return(result)
}
```

```{r}
visualize_both(mean_device_app_type_high, "High end data visualized for every app with app_type treatment")
```
Except for aliexpress every web app has a higher energy consumption. Aliexpress however also shows a high standard deviation for the native app, which could possibly indicate a measurement error.

```{r}
visualize_both(mean_device_app_type_low, "Low end data visualized for every app with app_type treatment")
```
The low end device's data has more deviation in the data with some outliers for example at weather_native and youtube_web.
